from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
import httpx
from bs4 import BeautifulSoup  # pip install beautifulsoup4

app = FastAPI()

class DppParseRequest(BaseModel):
    dpp_url: str
    point_collecte_code: str | None = None
    structure_operateur: str | None = None

class DppParseResponse(BaseModel):
    flux: str | None = None
    flux_sous: str | None = None
    famille: str | None = None
    sous_famille: str | None = None
    marque: str | None = None
    modele: str | None = None
    serie: str | None = None
    annee: int | None = None
    poids_kg: float | None = None
    brut: str | None = None

@app.post("/dpp/parse", response_model=DppParseResponse)
async def parse_dpp(req: DppParseRequest):
    # 1. Récupérer la page DPP (URL différente par produit, mais menus toujours au même endroit)
    try:
        async with httpx.AsyncClient(timeout=10) as client:
            r = await client.get(req.dpp_url)
        r.raise_for_status()
    except Exception as e:
        raise HTTPException(status_code=502, detail=f"Impossible d'accéder à l'URL DPP: {e}")

    html = r.text
    soup = BeautifulSoup(html, "html.parser")

    # 2. Extraire les infos dans les menus DPP
    # ⬇️ ICI tu mets les vrais sélecteurs CSS / id / classes de la page DPP (toujours mêmes menus)
    # Exemple purement fictif à adapter :
    def txt(selector):
        el = soup.select_one(selector)
        return el.get_text(strip=True) if el else None

    marque = txt("div.dpp-header span.brand")
    modele = txt("div.dpp-header span.model")
    serie = txt("div.dpp-technical span.serial")
    # flux / famille / sous-famille / poids peuvent être dans un tableau technique :
    flux = txt("table.dpp-specs tr[data-field='flux'] td.value")
    flux_sous = txt("table.dpp-specs tr[data-field='subflux'] td.value")
    famille = txt("table.dpp-specs tr[data-field='family'] td.value")
    sous_famille = txt("table.dpp-specs tr[data-field='subcategory'] td.value")
    poids_txt = txt("table.dpp-specs tr[data-field='weight'] td.value")
    annee_txt = txt("table.dpp-specs tr[data-field='year'] td.value")

    # 3. Normaliser poids / année
    poids_kg = None
    if poids_txt:
        # on garde uniquement les chiffres et le point/virgule
        import re
        m = re.search(r"([\d.,]+)", poids_txt)
        if m:
          poids_str = m.group(1).replace(",", ".")
          try:
            poids_kg = float(poids_str)
          except ValueError:
            poids_kg = None

    annee = None
    if annee_txt:
        try:
            annee = int(annee_txt[:4])
        except Exception:
            annee = None

    # 4. Retour JSON normalisé pour le front JARVIS
    return DppParseResponse(
        flux=flux,
        flux_sous=flux_sous,
        famille=famille,
        sous_famille=sous_famille,
        marque=marque,
        modele=modele,
        serie=serie,
        annee=annee,
        poids_kg=poids_kg,
        brut=f"URL: {req.dpp_url}",
    )
